package com.xcontent.service;

import com.xcontent.model.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.itextpdf.text.*;
import com.itextpdf.text.pdf.*;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.*;
import java.util.*;
import java.time.format.DateTimeFormatter;

@Service
public class MergeHistoryExportService {

    @Autowired
    private MergeHistoryService historyService;

    @Autowired
    private ObjectMapper objectMapper;

    /**
     * Ã£Æ’Å¾Ã£Æ’Â¼Ã£â€šÂ¸Ã¥Â±Â¥Ã¦Â­Â´Ã£ÂÂ®Ã£â€šÂ¨Ã£â€šÂ¯Ã£â€šÂ¹Ã£Æ’ÂÃ£Æ’Â¼Ã£Æ’Ë†
     */
    public byte[] exportMergeHistory(
            String templateId,
            String format,
            MergeHistoryExportOptions options) throws IOException {
        
        List<MergeHistory> history = historyService.getMergeHistory(
            templateId,
            options.getStartDate(),
            options.getEndDate()
        );

        switch (format.toLowerCase()) {
            case "json":
                return exportToJson(history, options);
            case "excel":
                return exportToExcel(history, options);
            case "pdf":
                return exportToPdf(history, options);
            case "csv":
                return exportToCsv(history, options);
            default:
                throw new IllegalArgumentException("Unsupported format: " + format);
        }
    }

    /**
     * JSONÃ£Æ’â€¢Ã£â€šÂ©Ã£Æ’Â¼Ã£Æ’Å¾Ã£Æ’Æ’Ã£Æ’Ë†Ã£ÂÂ§Ã£ÂÂ®Ã£â€šÂ¨Ã£â€šÂ¯Ã£â€šÂ¹Ã£Æ’ÂÃ£Æ’Â¼Ã£Æ’Ë†
     */
    private byte[] exportToJson(
            List<MergeHistory> history,
            MergeHistoryExportOptions options) throws IOException {
        
        Map<String, Object> exportData = new HashMap<>();
        exportData.put("exportDate", new Date());
        exportData.put("exportOptions", options);

        List<Map<String, Object>> merges = new ArrayList<>();
        for (MergeHistory merge : history) {
            Map<String, Object> mergeData = new HashMap<>();
            mergeData.put("id", merge.getId());
            mergeData.put("sourceVersion", merge.getSourceVersion());
            mergeData.put("targetVersion", merge.getTargetVersion());
            mergeData.put("resultVersion", merge.getResultVersion());
            mergeData.put("status", merge.getStatus());
            mergeData.put("mergedBy", merge.getMergedBy());
            mergeData.put("mergedAt", merge.getMergedAt());

            if (options.isIncludeConflicts()) {
                mergeData.put("conflicts", merge.getConflicts());
                mergeData.put("resolutions", merge.getResolutions());
            }

            if (options.isIncludeComments()) {
                mergeData.put("comment", merge.getComment());
            }

            merges.add(mergeData);
        }

        exportData.put("merges", merges);
        return objectMapper.writerWithDefaultPrettyPrinter()
            .writeValueAsBytes(exportData);
    }

    /**
     * ExcelÃ£Æ’â€¢Ã£â€šÂ©Ã£Æ’Â¼Ã£Æ’Å¾Ã£Æ’Æ’Ã£Æ’Ë†Ã£ÂÂ§Ã£ÂÂ®Ã£â€šÂ¨Ã£â€šÂ¯Ã£â€šÂ¹Ã£Æ’ÂÃ£Æ’Â¼Ã£Æ’Ë†
     */
    private byte[] exportToExcel(
            List<MergeHistory> history,
            MergeHistoryExportOptions options) throws IOException {
        
        try (Workbook workbook = new XSSFWorkbook()) {
            // Ã£â€šÂµÃ£Æ’Å¾Ã£Æ’ÂªÃ£Æ’Â¼Ã£â€šÂ·Ã£Æ’Â¼Ã£Æ’Ë†Ã£ÂÂ®Ã¤Â½Å“Ã¦Ë†Â
            Sheet summarySheet = workbook.createSheet("Summary");
            createSummarySheet(summarySheet, history);

            // Ã£Æ’Å¾Ã£Æ’Â¼Ã£â€šÂ¸Ã¥Â±Â¥Ã¦Â­Â´Ã£â€šÂ·Ã£Æ’Â¼Ã£Æ’Ë†Ã£ÂÂ®Ã¤Â½Å“Ã¦Ë†Â
            Sheet mergeSheet = workbook.createSheet("Merge History");
            createMergeHistorySheet(mergeSheet, history, options);

            // Ã£â€šÂ³Ã£Æ’Â³Ã£Æ’â€¢Ã£Æ’ÂªÃ£â€šÂ¯Ã£Æ’Ë†Ã£â€šÂ·Ã£Æ’Â¼Ã£Æ’Ë†Ã£ÂÂ®Ã¤Â½Å“Ã¦Ë†ÂÃ¯Â¼Ë†Ã£â€šÂªÃ£Æ’â€”Ã£â€šÂ·Ã£Æ’Â§Ã£Æ’Â³Ã¯Â¼â€°
            if (options.isIncludeConflicts()) {
                Sheet conflictSheet = workbook.createSheet("Conflicts");
                createConflictSheet(conflictSheet, history);
            }

            // Ã§ÂµÂ±Ã¨Â¨Ë†Ã£â€šÂ·Ã£Æ’Â¼Ã£Æ’Ë†Ã£ÂÂ®Ã¤Â½Å“Ã¦Ë†Â
            Sheet statsSheet = workbook.createSheet("Statistics");
            createStatisticsSheet(statsSheet, history);

            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            workbook.write(outputStream);
            return outputStream.toByteArray();
        }
    }

    /**
     * PDFÃ£Æ’â€¢Ã£â€šÂ©Ã£Æ’Â¼Ã£Æ’Å¾Ã£Æ’Æ’Ã£Æ’Ë†Ã£ÂÂ§Ã£ÂÂ®Ã£â€šÂ¨Ã£â€šÂ¯Ã£â€šÂ¹Ã£Æ’ÂÃ£Æ’Â¼Ã£Æ’Ë†
     */
    private byte[] exportToPdf(
            List<MergeHistory> history,
            MergeHistoryExportOptions options) throws IOException {
        
        Document document = new Document(PageSize.A4);
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();

        try {
            PdfWriter writer = PdfWriter.getInstance(document, outputStream);
            document.open();

            // Ã£â€šÂ¿Ã£â€šÂ¤Ã£Æ’Ë†Ã£Æ’Â«Ã£Æ’Å¡Ã£Æ’Â¼Ã£â€šÂ¸Ã£ÂÂ®Ã¨Â¿Â½Ã¥Å Â 
            addTitlePage(document, options);

            // Ã£â€šÂµÃ£Æ’Å¾Ã£Æ’ÂªÃ£Æ’Â¼Ã£â€šÂ»Ã£â€šÂ¯Ã£â€šÂ·Ã£Æ’Â§Ã£Æ’Â³Ã£ÂÂ®Ã¨Â¿Â½Ã¥Å Â 
            addSummarySection(document, history);

            // Ã£Æ’Å¾Ã£Æ’Â¼Ã£â€šÂ¸Ã¥Â±Â¥Ã¦Â­Â´Ã£â€šÂ»Ã£â€šÂ¯Ã£â€šÂ·Ã£Æ’Â§Ã£Æ’Â³Ã£ÂÂ®Ã¨Â¿Â½Ã¥Å Â 
            addMergeHistorySection(document, history, options);

            // Ã£â€šÂ³Ã£Æ’Â³Ã£Æ’â€¢Ã£Æ’ÂªÃ£â€šÂ¯Ã£Æ’Ë†Ã£â€šÂ»Ã£â€šÂ¯Ã£â€šÂ·Ã£Æ’Â§Ã£Æ’Â³Ã£ÂÂ®Ã¨Â¿Â½Ã¥Å Â Ã¯Â¼Ë†Ã£â€šÂªÃ£Æ’â€”Ã£â€šÂ·Ã£Æ’Â§Ã£Æ’Â³Ã¯Â¼â€°
            if (options.isIncludeConflicts()) {
                addConflictSection(document, history);
            }

            // Ã§ÂµÂ±Ã¨Â¨Ë†Ã£â€šÂ»Ã£â€šÂ¯Ã£â€šÂ·Ã£Æ’Â§Ã£Æ’Â³Ã£ÂÂ®Ã¨Â¿Â½Ã¥Å Â 
            addStatisticsSection(document, history);

            document.close();
            return outputStream.toByteArray();
        } catch (DocumentException e) {
            throw new IOException("Failed to generate PDF", e);
        }
    }

    /**
     * CSVÃ£Æ’â€¢Ã£â€šÂ©Ã£Æ’Â¼Ã£Æ’Å¾Ã£Æ’Æ’Ã£Æ’Ë†Ã£ÂÂ§Ã£ÂÂ®Ã£â€šÂ¨Ã£â€šÂ¯Ã£â€šÂ¹Ã£Æ’ÂÃ£Æ’Â¼Ã£Æ’Ë†
     */
    private byte[] exportToCsv(
            List<MergeHistory> history,
            MergeHistoryExportOptions options) throws IOException {
        
        StringWriter writer = new StringWriter();
        CSVWriter csvWriter = new CSVWriter(writer);

        // Ã£Æ’ËœÃ£Æ’Æ’Ã£Æ’â‚¬Ã£Æ’Â¼Ã£ÂÂ®Ã¦â€ºÂ¸Ã£ÂÂÃ¨Â¾Â¼Ã£ÂÂ¿
        String[] headers = {
            "Merge ID",
            "Source Version",
            "Target Version",
            "Result Version",
            "Status",
            "Merged By",
            "Merged At",
            "Affected Fields",
            "Has Conflicts",
            "Comment"
        };
        csvWriter.writeNext(headers);

        // Ã£Æ’â€¡Ã£Æ’Â¼Ã£â€šÂ¿Ã£ÂÂ®Ã¦â€ºÂ¸Ã£ÂÂÃ¨Â¾Â¼Ã£ÂÂ¿
        DateTimeFormatter dateFormatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
        for (MergeHistory merge : history) {
            String[] row = {
                merge.getId(),
                merge.getSourceVersion(),
                merge.getTargetVersion(),
                merge.getResultVersion(),
                merge.getStatus().toString(),
                merge.getMergedBy(),
                dateFormatter.format(merge.getMergedAt()),
                String.join(", ", merge.getAffectedFields()),
                String.valueOf(!merge.getConflicts().isEmpty()),
                merge.getComment()
            };
            csvWriter.writeNext(row);
        }

        csvWriter.close();
        return writer.toString().getBytes();
    }

    /**
     * ExcelÃ£â€šÂµÃ£Æ’Å¾Ã£Æ’ÂªÃ£Æ’Â¼Ã£â€šÂ·Ã£Æ’Â¼Ã£Æ’Ë†Ã£ÂÂ®Ã¤Â½Å“Ã¦Ë†Â
     */
    private void createSummarySheet(Sheet sheet, List<MergeHistory> history) {
        Row headerRow = sheet.createRow(0);
        headerRow.createCell(0).setCellValue("Summary Statistics");

        Row totalRow = sheet.createRow(1);
        totalRow.createCell(0).setCellValue("Total Merges");
        totalRow.createCell(1).setCellValue(history.size());

        Row successRow = sheet.createRow(2);
        successRow.createCell(0).setCellValue("Successful Merges");
        successRow.createCell(1).setCellValue(
            countMergesByStatus(history, MergeStatus.COMPLETED)
        );

        Row conflictRow = sheet.createRow(3);
        conflictRow.createCell(0).setCellValue("Conflicted Merges");
        conflictRow.createCell(1).setCellValue(
            countMergesWithConflicts(history)
        );

        Row failedRow = sheet.createRow(4);
        failedRow.createCell(0).setCellValue("Failed Merges");
        failedRow.createCell(1).setCellValue(
            countMergesByStatus(history, MergeStatus.FAILED)
        );
    }

    /**
     * ExcelÃ£Æ’Å¾Ã£Æ’Â¼Ã£â€šÂ¸Ã¥Â±Â¥Ã¦Â­Â´Ã£â€šÂ·Ã£Æ’Â¼Ã£Æ’Ë†Ã£ÂÂ®Ã¤Â½Å“Ã¦Ë†Â
     */
    private void createMergeHistorySheet(
            Sheet sheet,
            List<MergeHistory> history,
            MergeHistoryExportOptions options) {
        
        // Ã£Æ’ËœÃ£Æ’Æ’Ã£Æ’â‚¬Ã£Æ’Â¼Ã¨Â¡Å’Ã£ÂÂ®Ã¤Â½Å“Ã¦Ë†Â
        Row headerRow = sheet.createRow(0);
        int columnIndex = 0;
        headerRow.createCell(columnIndex++).setCellValue("Merge ID");
        headerRow.createCell(columnIndex++).setCellValue("Source Version");
        headerRow.createCell(columnIndex++).setCellValue("Target Version");
        headerRow.createCell(columnIndex++).setCellValue("Result Version");
        headerRow.createCell(columnIndex++).setCellValue("Status");
        headerRow.createCell(columnIndex++).setCellValue("Merged By");
        headerRow.createCell(columnIndex++).setCellValue("Merged At");
        headerRow.createCell(columnIndex++).setCellValue("Affected Fields");

        if (options.isIncludeConflicts()) {
            headerRow.createCell(columnIndex++).setCellValue("Conflicts");
            headerRow.createCell(columnIndex++).setCellValue("Resolutions");
        }

        if (options.isIncludeComments()) {
            headerRow.createCell(columnIndex).setCellValue("Comment");
        }

        // Ã£Æ’â€¡Ã£Æ’Â¼Ã£â€šÂ¿Ã¨Â¡Å’Ã£ÂÂ®Ã¤Â½Å“Ã¦Ë†Â
        int rowIndex = 1;
        for (MergeHistory merge : history) {
            Row row = sheet.createRow(rowIndex++);
            columnIndex = 0;

            row.createCell(columnIndex++).setCellValue(merge.getId());
            row.createCell(columnIndex++).setCellValue(merge.getSourceVersion());
            row.createCell(columnIndex++).setCellValue(merge.getTargetVersion());
            row.createCell(columnIndex++).setCellValue(merge.getResultVersion());
            row.createCell(columnIndex++).setCellValue(merge.getStatus().toString());
            row.createCell(columnIndex++).setCellValue(merge.getMergedBy());
            row.createCell(columnIndex++).setCellValue(
                formatDate(merge.getMergedAt())
            );
            row.createCell(columnIndex++).setCellValue(
                String.join(", ", merge.getAffectedFields())
            );

            if (options.isIncludeConflicts()) {
                row.createCell(columnIndex++).setCellValue(
                    formatConflicts(merge.getConflicts())
                );
                row.createCell(columnIndex++).setCellValue(
                    formatResolutions(merge.getResolutions())
                );
            }

            if (options.isIncludeComments()) {
                row.createCell(columnIndex).setCellValue(merge.getComment());
            }
        }

        // Ã¥Ë†â€”Ã¥Â¹â€¦Ã£ÂÂ®Ã¨â€¡ÂªÃ¥â€¹â€¢Ã¨ÂªÂ¿Ã¦â€¢Â´
        for (int i = 0; i < columnIndex; i++) {
            sheet.autoSizeColumn(i);
        }
    }

    /**
     * PDFÃ£â€šÂ¿Ã£â€šÂ¤Ã£Æ’Ë†Ã£Æ’Â«Ã£Æ’Å¡Ã£Æ’Â¼Ã£â€šÂ¸Ã£ÂÂ®Ã¨Â¿Â½Ã¥Å Â 
     */
    private void addTitlePage(
            Document document,
            MergeHistoryExportOptions options) throws DocumentException {
        
        Font titleFont = new Font(Font.FontFamily.HELVETICA, 24, Font.BOLD);
        Font subtitleFont = new Font(Font.FontFamily.HELVETICA, 16, Font.ITALIC);

        Paragraph title = new Paragraph("Merge History Report", titleFont);
        title.setAlignment(Element.ALIGN_CENTER);
        title.setSpacingAfter(50);
        document.add(title);

        Paragraph exportInfo = new Paragraph(
            "Export Date: " + formatDate(new Date().getTime()) + "\n" +
            "Date Range: " + formatDate(options.getStartDate()) + " - " +
            formatDate(options.getEndDate()),
            subtitleFont
        );
        exportInfo.setAlignment(Element.ALIGN_CENTER);
        document.add(exportInfo);

        document.newPage();
    }

    /**
     * PDFÃ£â€šÂµÃ£Æ’Å¾Ã£Æ’ÂªÃ£Æ’Â¼Ã£â€šÂ»Ã£â€šÂ¯Ã£â€šÂ·Ã£Æ’Â§Ã£Æ’Â³Ã£ÂÂ®Ã¨Â¿Â½Ã¥Å Â 
     */
    private void addSummarySection(
            Document document,
            List<MergeHistory> history) throws DocumentException {
        
        Font sectionFont = new Font(Font.FontFamily.HELVETICA, 16, Font.BOLD);
        Font normalFont = new Font(Font.FontFamily.HELVETICA, 12, Font.NORMAL);

        Paragraph section = new Paragraph("Summary", sectionFont);
        section.setSpacingAfter(20);
        document.add(section);

        PdfPTable table = new PdfPTable(2);
        table.setWidthPercentage(100);

        addTableRow(table, "Total Merges", String.valueOf(history.size()));
        addTableRow(table, "Successful Merges",
            String.valueOf(countMergesByStatus(history, MergeStatus.COMPLETED)));
        addTableRow(table, "Conflicted Merges",
            String.valueOf(countMergesWithConflicts(history)));
        addTableRow(table, "Failed Merges",
            String.valueOf(countMergesByStatus(history, MergeStatus.FAILED)));

        document.add(table);
        document.add(Chunk.NEWLINE);
    }

    /**
     * Ã£Æ’Â¦Ã£Æ’Â¼Ã£Æ’â€ Ã£â€šÂ£Ã£Æ’ÂªÃ£Æ’â€ Ã£â€šÂ£Ã£Æ’Â¡Ã£â€šÂ½Ã£Æ’Æ’Ã£Æ’â€°
     */
    private int countMergesByStatus(List<MergeHistory> history, MergeStatus status) {
        return (int) history.stream()
            .filter(m -> m.getStatus() == status)
            .count();
    }

    private int countMergesWithConflicts(List<MergeHistory> history) {
        return (int) history.stream()
            .filter(m -> !m.getConflicts().isEmpty())
            .count();
    }

    private String formatDate(Long timestamp) {
        return new Date(timestamp).toString();
    }

    private String formatConflicts(Map<String, Object> conflicts) {
        try {
            return objectMapper.writeValueAsString(conflicts);
        } catch (Exception e) {
            return "Error formatting conflicts";
        }
    }

    private String formatResolutions(Map<String, Object> resolutions) {
        try {
            return objectMapper.writeValueAsString(resolutions);
        } catch (Exception e) {
            return "Error formatting resolutions";
        }
    }

    private void addTableRow(PdfPTable table, String label, String value) {
        table.addCell(new Phrase(label));
        table.addCell(new Phrase(value));
    }
}

@Data
public class MergeHistoryExportOptions {
    private Long startDate;
    private Long endDate;
    private boolean includeConflicts;
    private boolean includeComments;
    private boolean includeStatistics;
    private String dateFormat;
    private List<String> includedFields;
    private Map<String, String> customHeaders;
}
