package com.xcontent.ui.service;

import com.xcontent.ui.model.*;
import com.xcontent.ui.repository.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.*;
import java.util.concurrent.CompletableFuture;

@Service
public class DashboardService {
    @Autowired
    private DashboardWidgetRepository widgetRepository;
    @Autowired
    private DashboardLayoutRepository layoutRepository;

    public DashboardLayout getUserDashboard(String userId) {
        return layoutRepository.findByUserIdAndIsDefaultTrue(userId)
            .orElseGet(() -> createDefaultDashboard(userId));
    }

    @Transactional
    public DashboardLayout saveDashboardLayout(
            String userId,
            String name,
            List<LayoutItem> items) {

        DashboardLayout layout = new DashboardLayout();
        layout.setUserId(userId);
        layout.setName(name);
        layout.setItems(items);
        layout.setCreatedAt(System.currentTimeMillis());
        layout.setUpdatedAt(System.currentTimeMillis());

        return layoutRepository.save(layout);
    }

    public Map<String, Object> getWidgetData(String widgetId) {
        DashboardWidget widget = widgetRepository.findById(widgetId)
            .orElseThrow(() -> new IllegalArgumentException("Widget not found"));

        if (isDataStale(widget)) {
            refreshWidgetData(widget);
        }

        return widget.getData();
    }

    @Async
    public CompletableFuture<Void> refreshWidgetData(DashboardWidget widget) {
        try {
            widget.setStatus(WidgetStatus.LOADING);
            widgetRepository.save(widget);

            Map<String, Object> newData = fetchWidgetData(widget);
            widget.setData(newData);
            widget.setStatus(WidgetStatus.ACTIVE);
            widget.setLastUpdated(System.currentTimeMillis());

        } catch (Exception e) {
            widget.setStatus(WidgetStatus.ERROR);
        }

        widgetRepository.save(widget);
        return CompletableFuture.completedFuture(null);
    }

    private Map<String, Object> fetchWidgetData(DashboardWidget widget) {
        switch (widget.getType()) {
            case "templateStats":
                return fetchTemplateStatistics();
            case "performanceMetrics":
                return fetchPerformanceMetrics();
            case "recentActivity":
                return fetchRecentActivity();
            default:
                throw new IllegalArgumentException("Unknown widget type");
        }
    }

    private boolean isDataStale(DashboardWidget widget) {
        return System.currentTimeMillis() - widget.getLastUpdated() > widget.getRefreshInterval();
    }
}

@Service
public class PreviewService {
    @Autowired
    private TemplateService templateService;

    public String generatePreview(
            String templateId,
            String version,
            Map<String, Object> parameters) {

        Template template = templateService.getTemplate(templateId, version);
        validateParameters(template, parameters);

        String previewHtml = renderTemplate(template, parameters);
        return injectPreviewTools(previewHtml);
    }

    public Map<String, Object> getPreviewMetadata(
            String templateId,
            String version) {

        Template template = templateService.getTemplate(templateId, version);
        
        Map<String, Object> metadata = new HashMap<>();
        metadata.put("parameters", getParameterDefinitions(template));
        metadata.put("variables", getAvailableVariables(template));
        metadata.put("styles", getStyleDefinitions(template));
        
        return metadata;
    }

    private String injectPreviewTools(String html) {
        StringBuilder sb = new StringBuilder(html);
        
        // Ã£Æ’â€”Ã£Æ’Â¬Ã£Æ’â€œÃ£Æ’Â¥Ã£Æ’Â¼Ã£Æ’â€žÃ£Æ’Â¼Ã£Æ’Â«Ã£Æ’ÂÃ£Æ’Â¼Ã£ÂÂ®Ã¦Å’Â¿Ã¥â€¦Â¥
        sb.insert(0, generatePreviewToolbar());
        
        // Ã£Æ’â€”Ã£Æ’Â¬Ã£Æ’â€œÃ£Æ’Â¥Ã£Æ’Â¼Ã£â€šÂ¹Ã£â€šÂ¯Ã£Æ’ÂªÃ£Æ’â€”Ã£Æ’Ë†Ã£ÂÂ®Ã¦Å’Â¿Ã¥â€¦Â¥
        sb.append(generatePreviewScript());
        
        return sb.toString();
    }

    private String generatePreviewToolbar() {
        return "<div class='preview-toolbar'>" +
               "  <button onclick='refreshPreview()'>Refresh</button>" +
               "  <button onclick='toggleGrid()'>Toggle Grid</button>" +
               "  <select onchange='changeViewport(this.value)'>" +
               "    <option value='desktop'>Desktop</option>" +
               "    <option value='tablet'>Tablet</option>" +
               "    <option value='mobile'>Mobile</option>" +
               "  </select>" +
               "</div>";
    }

    private String generatePreviewScript() {
        return "<script>" +
               "  function refreshPreview() { /* ... */ }" +
               "  function toggleGrid() { /* ... */ }" +
               "  function changeViewport(device) { /* ... */ }" +
               "</script>";
    }
}

@Service
public class ReportService {
    @Autowired
    private ReportRepository reportRepository;
    @Autowired
    private ReportGeneratorFactory generatorFactory;
    @Autowired
    private NotificationService notificationService;

    @Transactional
    public Report createReport(
            String name,
            ReportType type,
            ReportFormat format,
            Map<String, Object> parameters) {

        Report report = new Report();
        report.setName(name);
        report.setType(type);
        report.setFormat(format);
        report.setParameters(parameters);
        report.setStatus(ReportStatus.DRAFT);
        report.setCreatedAt(System.currentTimeMillis());
        report.setCreatedBy("current_user");

        return reportRepository.save(report);
    }

    @Async
    public CompletableFuture<Report> generateReport(String reportId) {
        Report report = reportRepository.findById(reportId)
            .orElseThrow(() -> new IllegalArgumentException("Report not found"));

        try {
            report.setStatus(ReportStatus.GENERATING);
            reportRepository.save(report);

            ReportGenerator generator = generatorFactory.getGenerator(report.getType());
            Map<String, Object> data = generator.generateData(report.getParameters());
            report.setData(data);

            report.setStatus(ReportStatus.COMPLETED);
            notifyReportCompletion(report);

        } catch (Exception e) {
            report.setStatus(ReportStatus.FAILED);
            notifyReportFailure(report, e);
        }

        return CompletableFuture.completedFuture(
            reportRepository.save(report)
        );
    }

    @Scheduled(cron = "0 0 * * * *") // Ã¦Â¯Å½Ã¦â„¢â€šÃ¥Â®Å¸Ã¨Â¡Å’
    public void generateScheduledReports() {
        List<Report> scheduledReports = reportRepository
            .findByStatusAndScheduledAtBefore(
                ReportStatus.SCHEDULED,
                System.currentTimeMillis()
            );

        for (Report report : scheduledReports) {
            generateReport(report.getId());
        }
    }

    private void notifyReportCompletion(Report report) {
        if (report.getRecipients() != null) {
            for (String recipient : report.getRecipients()) {
                notificationService.sendReportNotification(
                    recipient,
                    "Report " + report.getName() + " is ready",
                    generateReportSummary(report)
                );
            }
        }
    }

    private void notifyReportFailure(Report report, Exception e) {
        if (report.getRecipients() != null) {
            for (String recipient : report.getRecipients()) {
                notificationService.sendReportNotification(
                    recipient,
                    "Report " + report.getName() + " generation failed",
                    e.getMessage()
                );
            }
        }
    }

    private Map<String, Object> generateReportSummary(Report report) {
        Map<String, Object> summary = new HashMap<>();
        summary.put("reportId", report.getId());
        summary.put("name", report.getName());
        summary.put("type", report.getType());
        summary.put("format", report.getFormat());
        summary.put("generatedAt", report.getCreatedAt());
        return summary;
    }
}
